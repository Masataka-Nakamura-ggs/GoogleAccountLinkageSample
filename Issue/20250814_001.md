# 役割
あなたは、フルスタック開発とDevOpsに精通したシニアソリューションアーキテクトです。Java(Spring Boot)とJavaScript(Next.js)を用いたセキュアなWebアプリケーションの構築、およびDockerを使ったコンテナ化の経験が豊富です。

# 遵守事項
作業内容はagent_log配下に随時作成すること
agent_log配下に作成する作業ログは、適宜異なるファイルに記載していくこと
  例）20250814_001_step1.md

# 参考資料
docs/Googleアカウント連携.md

# ゴール
Googleアカウント連携.mdに基づき、OIDC(OpenID Connect)によるID連携を行うサンプルWebアプリケーションを構築します。このアプリケーションは、以下の技術スタックを使用し、Docker Composeで一括して起動できるようにします。

- **IDプロバイダー(IdP)役 (OneAccount/GCIPの代役):** Keycloak
- **バックエンド(RP)役 (GMOコインサーバーの代役):** Java + Spring Boot 3 + Gradle 8.5
- **フロントエンド(RP)役 (GMOコイン画面の代役):** React + Next.js + Tailwind CSS

最終的に、ユーザーが `docker-compose up --build` を実行するだけで、ローカル環境 (http://localhost:3000) でID連携のフローを完全に試せるコード一式を生成してください。

# 全体のシステム構成
このサンプルは、`docker-compose.yml` で定義される以下の3つのサービスで構成します。

1.  `keycloak`: IDプロバイダー。ユーザー認証とトークン発行を担当します。
2.  `backend-api`: Spring Boot製のRPバックエンド。フロントエンドからの要求を受け、トークンを検証し、保護されたAPIを提供します。
3.  `frontend-app`: Next.js製のRPフロントエンド。ユーザーにログイン画面を提供し、認証後はバックエンドAPIから情報を取得して表示します。

---

# 生成手順
以下のステップに従って、必要なファイルとコードをすべて生成してください。ファイル名が明記されているものは、その名前でコードブロックを作成してください。

### ステップ1: プロジェクト全体のディレクトリ構造
まず、完成形のディレクトリ構造を提示してください。

### ステップ2: Docker Compose の設定
プロジェクトのルートに `docker-compose.yml` を作成します。3つのサービス（keycloak, backend-api, frontend-app）を定義し、それぞれが連携できるようにネットワークと環境変数を設定してください。

### ステップ3: IDプロバイダー (Keycloak) の設定
KeycloakをIdPとして機能させるための設定ファイルを作成します。これは `docker-compose.yml` からマウントされ、Keycloak起動時にレルム、クライアント、テストユーザーを自動で作成します。

- ファイル名: `./keycloak/realm-export.json`
- 設定内容:
    - レルム名: `one-account-realm`
    - クライアントID: `gmo-coin-client`
    - クライアントのアクセスタイプ: `public`
    - 有効なリダイレクトURI: `http://localhost:3000/*`
    - Web Origins: `http://localhost:3000`
    - テストユーザー: `user01` / `password` (メールアドレスや氏名も設定)

### ステップ4: バックエンド (Spring Boot API) の実装
`backend-api` ディレクトリ内にSpring Bootアプリケーションを作成します。

1.  **`build.gradle`**:
    - `Spring Boot 3.2.x` を使用。
    - 必要な依存関係 (`spring-boot-starter-web`, `spring-boot-starter-oauth2-client`) を含めてください。

2.  **`Dockerfile`**:
    - `backend-api/Dockerfile` として作成。
    - Gradleを使ってアプリケーションをビルドし、実行するマルチステージビルドにしてください。

3.  **`application.yml`**:
    - `src/main/resources/application.yml` として作成。
    - Spring SecurityとOIDCの設定を記述します。`issuer-uri` はDockerネットワーク内のKeycloak (`http://keycloak:8080/realms/one-account-realm`) を指すように設定してください。
    - クライアントIDと（必要であれば）シークレットを設定します。

4.  **`SecurityConfig.java`**:
    - OIDCログインを有効にし、APIエンドポイント (`/api/**`) を認証必須にするセキュリティ設定クラスを作成してください。
    - フロントエンド(Next.js)からのCORSリクエストを許可する設定も追加してください。

5.  **`UserInfoController.java`**:
    - 認証されたユーザーの情報を返す簡単なRESTコントローラーを作成します。
    - `/api/user` エンドポイントで、認証済みの `OidcUser` オブジェクトから氏名、メールアドレスなどのクレームを取得して返却する処理を実装してください。

### ステップ5: フロントエンド (Next.js App) の実装
`frontend-app` ディレクトリ内にNext.jsアプリケーションを作成します。

1.  **`package.json`**:
    - `next`, `react`, `react-dom`, `tailwindcss` に加え、認証処理のための `next-auth` を依存関係に追加してください。

2.  **`Dockerfile`**:
    - `frontend-app/Dockerfile` として作成。
    - 依存関係のインストール、アプリケーションのビルド、Next.jsサーバーの起動を行うマルチステージビルドにしてください。

3.  **NextAuth設定 (`[...nextauth].ts`)**:
    - `app/api/auth/[...nextauth]/route.ts` として作成。
    - `next-auth` の設定を記述します。プロバイダーとしてKeycloakを設定し、バックエンドの `application.yml` と対応する `clientId`, `issuer` を設定してください。
    - JWTコールバックで、IdPから受け取った `id_token` や `access_token` をセッションに含めるように実装してください。

4.  **UIコンポーネント (`page.tsx`)**:
    - `app/page.tsx` を作成。
    - ユーザーが認証済みかどうかで表示を切り替えます。
        - **未認証時:** 「GMOコインにログイン(OneAccountを利用)」ボタンを表示します。
        - **認証済み:**
            - 「ようこそ、{ユーザー名}さん」と表示します。
            - バックエンドAPI (`http://localhost:8080/api/user`) にリクエストを送信し、取得したユーザー情報を表示するコンポーネントを作成します。この際、`next-auth` のセッショントークンをAuthorizationヘッダーに付与してリクエストを送信する処理を実装してください。
            - ログアウトボタンを設置してください。

5.  **Tailwind CSS 設定**:
    - `tailwind.config.ts` と `globals.css` の基本的な設定ファイルも生成してください。

### ステップ6: 最終的な実行手順
生成したすべてのコードをどのように配置し、`docker-compose up --build` コマンドで起動して、どのURLにアクセスすれば動作確認できるかを、初心者にもわかるように丁寧に説明してください。

